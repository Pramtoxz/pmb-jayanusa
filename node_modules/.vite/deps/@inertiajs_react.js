import {
  Ie,
  Me,
  Ne,
  Te,
  Wr
} from "./chunk-PWD2DO47.js";
import {
  require_react
} from "./chunk-YJYY6GXC.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer = moduleExports ? root.Buffer : void 0;
    var Symbol = root.Symbol;
    var Uint8Array = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@inertiajs/react/dist/index.esm.js
var import_react = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_react3 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react5 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var import_react7 = __toESM(require_react());
var import_react8 = __toESM(require_react());
var import_lodash = __toESM(require_lodash());
var import_react9 = __toESM(require_react());
var import_react10 = __toESM(require_react());
var import_react11 = __toESM(require_react());
var import_react12 = __toESM(require_react());
var import_react13 = __toESM(require_react());
var oe = (0, import_react3.createContext)(void 0);
oe.displayName = "InertiaHeadContext";
var M = oe;
var ne = (0, import_react4.createContext)(void 0);
ne.displayName = "InertiaPageContext";
var L = ne;
function W({ children: u, initialPage: o, initialComponent: n, resolveComponent: s, titleCallback: a, onHeadUpdate: m }) {
  let [p, g] = (0, import_react2.useState)({ component: n || null, page: o, key: null }), P = (0, import_react2.useMemo)(() => Ie(typeof window > "u", a || ((l) => l), m || (() => {
  })), []);
  if ((0, import_react2.useEffect)(() => {
    Wr.init({ initialPage: o, resolveComponent: s, swapComponent: async ({ component: l, page: e, preserveState: f }) => {
      g((t) => ({ component: l, page: e, key: f ? t.key : Date.now() }));
    } }), Wr.on("navigate", () => P.forceUpdate());
  }, []), !p.component) return (0, import_react2.createElement)(M.Provider, { value: P }, (0, import_react2.createElement)(L.Provider, { value: p.page }, null));
  let y = u || (({ Component: l, props: e, key: f }) => {
    let t = (0, import_react2.createElement)(l, { key: f, ...e });
    return typeof l.layout == "function" ? l.layout(t) : Array.isArray(l.layout) ? l.layout.concat(t).reverse().reduce((h, T) => (0, import_react2.createElement)(T, { children: h, ...e })) : t;
  });
  return (0, import_react2.createElement)(M.Provider, { value: P }, (0, import_react2.createElement)(L.Provider, { value: p.page }, y({ Component: p.component, key: p.key, props: p.page.props })));
}
W.displayName = "Inertia";
async function ae({ id: u = "app", resolve: o, setup: n, title: s, progress: a = {}, page: m, render: p }) {
  let g = typeof window > "u", P = g ? null : document.getElementById(u), y = m || JSON.parse(P.dataset.page), l = (t) => Promise.resolve(o(t)).then((h) => h.default || h), e = [], f = await Promise.all([l(y.component), Wr.decryptHistory().catch(() => {
  })]).then(([t]) => n({ el: P, App: W, props: { initialPage: y, initialComponent: t, resolveComponent: l, titleCallback: s, onHeadUpdate: g ? (h) => e = h : null } }));
  if (!g && a && Ne(a), g) {
    let t = await p((0, import_react.createElement)("div", { id: u, "data-page": JSON.stringify(y) }, f));
    return { head: e, body: t };
  }
}
function K() {
  let u = (0, import_react6.useContext)(L);
  if (!u) throw new Error("usePage must be used within the Inertia component");
  return u;
}
var ie = ({ children: u, data: o, fallback: n }) => {
  if (!o) throw new Error("`<Deferred>` requires a `data` prop");
  let [s, a] = (0, import_react5.useState)(false), m = K().props, p = Array.isArray(o) ? o : [o];
  return (0, import_react5.useEffect)(() => {
    a(p.every((g) => m[g] !== void 0));
  }, [m, p]), s ? u : n;
};
ie.displayName = "InertiaDeferred";
var Ae = ie;
var Me2 = function({ children: u, title: o }) {
  let n = (0, import_react7.useContext)(M), s = (0, import_react7.useMemo)(() => n.createProvider(), [n]);
  (0, import_react7.useEffect)(() => () => {
    s.disconnect();
  }, [s]);
  function a(e) {
    return ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"].indexOf(e.type) > -1;
  }
  function m(e) {
    let f = Object.keys(e.props).reduce((t, h) => {
      if (["head-key", "children", "dangerouslySetInnerHTML"].includes(h)) return t;
      let T = e.props[h];
      return T === "" ? t + ` ${h}` : t + ` ${h}="${T}"`;
    }, "");
    return `<${e.type}${f}>`;
  }
  function p(e) {
    return typeof e.props.children == "string" ? e.props.children : e.props.children.reduce((f, t) => f + g(t), "");
  }
  function g(e) {
    let f = m(e);
    return e.props.children && (f += p(e)), e.props.dangerouslySetInnerHTML && (f += e.props.dangerouslySetInnerHTML.__html), a(e) || (f += `</${e.type}>`), f;
  }
  function P(e) {
    return import_react7.default.cloneElement(e, { inertia: e.props["head-key"] !== void 0 ? e.props["head-key"] : "" });
  }
  function y(e) {
    return g(P(e));
  }
  function l(e) {
    let f = import_react7.default.Children.toArray(e).filter((t) => t).map((t) => y(t));
    return o && !f.find((t) => t.startsWith("<title")) && f.push(`<title inertia>${o}</title>`), f;
  }
  return s.update(l(u)), null;
};
var Le = Me2;
var k = () => {
};
var le = (0, import_react8.forwardRef)(({ children: u, as: o = "a", data: n = {}, href: s, method: a = "get", preserveScroll: m = false, preserveState: p = null, replace: g = false, only: P = [], except: y = [], headers: l = {}, queryStringArrayFormat: e = "brackets", async: f = false, onClick: t = k, onCancelToken: h = k, onBefore: T = k, onStart: x = k, onProgress: I = k, onFinish: q = k, onCancel: N = k, onSuccess: J = k, onError: O = k, prefetch: F = false, cacheFor: b = 0, ...Q }, Y) => {
  let [z, V] = (0, import_react8.useState)(0), D = (0, import_react8.useRef)(null);
  o = o.toLowerCase(), a = a.toLowerCase();
  let [E, G] = Te(a, s || "", n, e);
  s = E, n = G;
  let U = { data: n, method: a, preserveScroll: m, preserveState: p ?? a !== "get", replace: g, only: P, except: y, headers: l, async: f }, $ = { ...U, onCancelToken: h, onBefore: T, onStart(c) {
    V((d) => d + 1), x(c);
  }, onProgress: I, onFinish(c) {
    V((d) => d - 1), q(c);
  }, onCancel: N, onSuccess: J, onError: O }, w = () => {
    Wr.prefetch(s, U, { cacheFor: X });
  }, C = (0, import_react8.useMemo)(() => F === true ? ["hover"] : F === false ? [] : Array.isArray(F) ? F : [F], Array.isArray(F) ? F : [F]), X = (0, import_react8.useMemo)(() => b !== 0 ? b : C.length === 1 && C[0] === "click" ? 0 : 3e4, [b, C]);
  (0, import_react8.useEffect)(() => () => {
    clearTimeout(D.current);
  }, []), (0, import_react8.useEffect)(() => {
    C.includes("mount") && setTimeout(() => w());
  }, C);
  let j = { onClick: (c) => {
    t(c), Me(c) && (c.preventDefault(), Wr.visit(s, $));
  } }, i = { onMouseEnter: () => {
    D.current = window.setTimeout(() => {
      w();
    }, 75);
  }, onMouseLeave: () => {
    clearTimeout(D.current);
  }, onClick: j.onClick }, S = { onMouseDown: (c) => {
    Me(c) && (c.preventDefault(), w());
  }, onMouseUp: (c) => {
    c.preventDefault(), Wr.visit(s, $);
  }, onClick: (c) => {
    t(c), Me(c) && c.preventDefault();
  } };
  return a !== "get" && (o = "button"), (0, import_react8.createElement)(o, { ...Q, ...{ a: { href: s }, button: { type: "button" } }[o] || {}, ref: Y, ...(() => C.includes("hover") ? i : C.includes("click") ? S : j)(), "data-loading": z > 0 ? "" : void 0 }, u);
});
le.displayName = "InertiaLink";
var $e = le;
function H(u, o) {
  let [n, s] = (0, import_react10.useState)(() => {
    let a = Wr.restore(o);
    return a !== void 0 ? a : u;
  });
  return (0, import_react10.useEffect)(() => {
    Wr.remember(n, o);
  }, [n, o]), [n, s];
}
function me(u, o) {
  let n = (0, import_react9.useRef)(null), s = typeof u == "string" ? u : null, [a, m] = (0, import_react9.useState)((typeof u == "string" ? o : u) || {}), p = (0, import_react9.useRef)(null), g = (0, import_react9.useRef)(null), [P, y] = s ? H(a, `${s}:data`) : (0, import_react9.useState)(a), [l, e] = s ? H({}, `${s}:errors`) : (0, import_react9.useState)({}), [f, t] = (0, import_react9.useState)(false), [h, T] = (0, import_react9.useState)(false), [x, I] = (0, import_react9.useState)(null), [q, N] = (0, import_react9.useState)(false), [J, O] = (0, import_react9.useState)(false), F = (0, import_react9.useRef)((i) => i);
  (0, import_react9.useEffect)(() => (n.current = true, () => {
    n.current = false;
  }), []);
  let b = (0, import_react9.useCallback)((i, S, r = {}) => {
    let c = { ...r, onCancelToken: (d) => {
      if (p.current = d, r.onCancelToken) return r.onCancelToken(d);
    }, onBefore: (d) => {
      if (N(false), O(false), clearTimeout(g.current), r.onBefore) return r.onBefore(d);
    }, onStart: (d) => {
      if (T(true), r.onStart) return r.onStart(d);
    }, onProgress: (d) => {
      if (I(d), r.onProgress) return r.onProgress(d);
    }, onSuccess: (d) => {
      if (n.current && (T(false), I(null), e({}), t(false), N(true), O(true), g.current = setTimeout(() => {
        n.current && O(false);
      }, 2e3)), r.onSuccess) return r.onSuccess(d);
    }, onError: (d) => {
      if (n.current && (T(false), I(null), e(d), t(true)), r.onError) return r.onError(d);
    }, onCancel: () => {
      if (n.current && (T(false), I(null)), r.onCancel) return r.onCancel();
    }, onFinish: (d) => {
      if (n.current && (T(false), I(null)), p.current = null, r.onFinish) return r.onFinish(d);
    } };
    i === "delete" ? Wr.delete(S, { ...c, data: F.current(P) }) : Wr[i](S, F.current(P), c);
  }, [P, e, F]), Q = (0, import_react9.useCallback)((i, S) => {
    y(typeof i == "string" ? (r) => ({ ...r, [i]: S }) : typeof i == "function" ? (r) => i(r) : i);
  }, [y]), Y = (0, import_react9.useCallback)((i, S) => {
    m(typeof i > "u" ? () => P : (r) => ({ ...r, ...typeof i == "string" ? { [i]: S } : i }));
  }, [P, m]), z = (0, import_react9.useCallback)((...i) => {
    i.length === 0 ? y(a) : y((S) => Object.keys(a).filter((r) => i.includes(r)).reduce((r, c) => (r[c] = a[c], r), { ...S }));
  }, [y, a]), V = (0, import_react9.useCallback)((i, S) => {
    e((r) => {
      let c = { ...r, ...typeof i == "string" ? { [i]: S } : i };
      return t(Object.keys(c).length > 0), c;
    });
  }, [e, t]), D = (0, import_react9.useCallback)((...i) => {
    e((S) => {
      let r = Object.keys(S).reduce((c, d) => ({ ...c, ...i.length > 0 && !i.includes(d) ? { [d]: S[d] } : {} }), {});
      return t(Object.keys(r).length > 0), r;
    });
  }, [e, t]), E = (i) => (S, r) => {
    b(i, S, r);
  }, G = (0, import_react9.useCallback)(E("get"), [b]), U = (0, import_react9.useCallback)(E("post"), [b]), $ = (0, import_react9.useCallback)(E("put"), [b]), w = (0, import_react9.useCallback)(E("patch"), [b]), C = (0, import_react9.useCallback)(E("delete"), [b]), X = (0, import_react9.useCallback)(() => {
    p.current && p.current.cancel();
  }, []), j = (0, import_react9.useCallback)((i) => {
    F.current = i;
  }, []);
  return { data: P, setData: Q, isDirty: !(0, import_lodash.default)(P, a), errors: l, hasErrors: f, processing: h, progress: x, wasSuccessful: q, recentlySuccessful: J, transform: j, setDefaults: Y, reset: z, setError: V, clearErrors: D, submit: b, get: G, post: U, put: $, patch: w, delete: C, cancel: X };
}
function ge(u, o = {}, n = { keepAlive: false, autoStart: true }) {
  let s = (0, import_react11.useRef)(Wr.poll(u, o, { ...n, autoStart: false }));
  return (0, import_react11.useEffect)(() => ((n.autoStart ?? true) && s.current.start(), () => s.current.stop()), []), { stop: s.current.stop, start: s.current.start };
}
function Pe(u = {}) {
  let o = typeof window > "u" ? null : Wr.getCached(window.location.pathname, u), n = typeof window > "u" ? null : Wr.getPrefetching(window.location.pathname, u), [s, a] = (0, import_react12.useState)((o == null ? void 0 : o.staleTimestamp) || null), [m, p] = (0, import_react12.useState)(n !== null), [g, P] = (0, import_react12.useState)(o !== null);
  return (0, import_react12.useEffect)(() => {
    let y = Wr.on("prefetching", (e) => {
      e.detail.visit.url.pathname === window.location.pathname && p(true);
    }), l = Wr.on("prefetched", (e) => {
      e.detail.visit.url.pathname === window.location.pathname && (p(false), P(true), a(e.detail.fetchedAt));
    });
    return () => {
      l(), y();
    };
  }, []), { lastUpdatedAt: s, isPrefetching: m, isPrefetched: g, flush: () => Wr.flush(window.location.pathname, u) };
}
var ye = ({ children: u, data: o, params: n, buffer: s, as: a, always: m, fallback: p }) => {
  m = m ?? false, a = a ?? "div", p = p ?? null;
  let [g, P] = (0, import_react13.useState)(false), y = (0, import_react13.useRef)(false), l = (0, import_react13.useRef)(false), e = (0, import_react13.useRef)(null), f = (0, import_react13.useCallback)(() => {
    if (o) return { only: Array.isArray(o) ? o : [o] };
    if (!n) throw new Error("You must provide either a `data` or `params` prop.");
    return n;
  }, [n, o]);
  return (0, import_react13.useEffect)(() => {
    if (!e.current) return;
    let t = new IntersectionObserver((h) => {
      if (!h[0].isIntersecting || (!m && y.current && t.disconnect(), l.current)) return;
      y.current = true, l.current = true;
      let T = f();
      Wr.reload({ ...T, onStart: (x) => {
        var _a;
        l.current = true, (_a = T.onStart) == null ? void 0 : _a.call(T, x);
      }, onFinish: (x) => {
        var _a;
        P(true), l.current = false, (_a = T.onFinish) == null ? void 0 : _a.call(T, x), m || t.disconnect();
      } });
    }, { rootMargin: `${s || 0}px` });
    return t.observe(e.current), () => {
      t.disconnect();
    };
  }, [e, f, s]), m || !g ? (0, import_react13.createElement)(a, { props: null, ref: e }, g ? u : p) : g ? u : null;
};
ye.displayName = "InertiaWhenVisible";
var tt = ye;
var Sr = Wr;
export {
  Ae as Deferred,
  Le as Head,
  $e as Link,
  tt as WhenVisible,
  ae as createInertiaApp,
  Sr as router,
  me as useForm,
  K as usePage,
  ge as usePoll,
  Pe as usePrefetch,
  H as useRemember
};
//# sourceMappingURL=@inertiajs_react.js.map
